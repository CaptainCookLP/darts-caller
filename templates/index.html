<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <script type="text/javascript" src="/static/js/common.js?v=1.0.1"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/static/css/common.css?v=1.0.0">
    <style>
        body{
            text-align: center;
            background-color: black;
            color: white
        }
    </style>
    <title>autodarts-caller</title>
</head>

<body>
    <button id="button">Click me to start calling!</button>
    <audio id="audio" preload="auto"></audio>
    <h1 id="status" style="visibility:hidden;">Disconnected!</h1>
    <h1 id="last-call" style="visibility:hidden;">Waiting for calls ..</h1>

    <script>
        const audio = document.getElementById('audio');
        const button = document.getElementById('button');
        const state = document.getElementById('status');
        const lastCall = document.getElementById('last-call');
        let db;

        button.addEventListener('click', onButtonClick);

        let audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let audioQueue = Promise.resolve();
        let previousWait = false;


        function getFilename(path) {
            let separator = path.includes('/') ? '/' : '\\';
            let parts = path.split(separator);
            return parts[parts.length - 1];
        }

        function fetchAndPlay(file) {
            return new Promise((resolve, reject) => {
                let path = file.path;

                // Zuerst versuchen, die Audiodatei aus dem Cache abzurufen
                getAudio(path)
                    .then(audioBlob => {
                        if (audioBlob) {
                            // Wenn die Audiodatei im Cache gefunden wurde, spiele sie ab
                            playAudio(audioBlob, file, true)
                                .then(() => {
                                    resolve();
                                })
                                .catch(error => {
                                    reject(error);
                                });
                        } else {
                            // Wenn die Audiodatei nicht im Cache gefunden wurde, vom Server holen und cachen
                            let fileUrl = `/sounds/${path}`;
                            fetch(fileUrl, {
                                method: "GET",
                                headers: {
                                    "Content-Type": "audio/mpeg"
                                },
                            })
                            .then(response => response.arrayBuffer())
                            .then(arrayBuffer => {
                                // Audio im Cache speichern
                                cacheAudio(path, arrayBuffer);
                                
                                // Audio abspielen
                                playAudio(arrayBuffer, file, false)
                                    .then(() => {
                                        resolve();
                                    })
                                    .catch(error => {
                                        reject(error);
                                    });
                            })
                            .catch(err => {
                                console.error(err);
                                reject(err);
                            });
                        }
                    })
                    .catch(err => {
                        console.error(err);
                        reject(err);
                    });
            });
        }

        function playAudio(audioBlob, file, fromCache) {
            return new Promise((resolve, reject) => {
                audioContext.decodeAudioData(audioBlob)
                    .then(audioBuffer => {
                        let source = audioContext.createBufferSource();
                        source.buffer = audioBuffer;
                        let gainNode = audioContext.createGain();
                        gainNode.gain.value = file.volume;
                        source.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        // Auflösen der Promise, wenn der Sound abgespielt wurde
                        source.onended = () => {
                            resolve();
                        };
                        source.start();

                        lastCall.innerText = getFilename(unescape(file.path));
                        if(fromCache){
                            lastCall.style = "color:orange;"
                            console.log("Play sound (by cache): ", file.path);
                        }else{
                            lastCall.style = "color:lightblue;"
                            console.log("Play sound (by download): ", file.path);
                            
                        }
                        
                         
                    })
                    .catch(err => {
                        console.error(err);
                        reject(err);
                    });
            });
        }

        function cacheAudio(path, audioBuffer) {
            // Kopiere das ArrayBuffer, um die Detached-Exception zu vermeiden
            const copiedBuffer = audioBuffer.slice(0);

            // Öffne die Datenbank
            db.open().then(() => {
                // Füge die Audiodatei zur Tabelle hinzu
                db.sounds.put({ path, file: copiedBuffer })
                    .then(() => {
                        console.log(`Caching successful (${path})`);
                    })
                    .catch(error => {
                        console.error(`Caching failed (${path}): ${error}`);
                    });
            });
        }

        function getAudio(path) {
            // Öffne die Datenbank
            return db.open()
                .then(() => db.sounds.get(path))
                .then(result => {
                    if (result) {
                        console.log(`Using cached (${path})`);
                        return result.file;
                    } else {
                        console.log(`No cache for (${path})`);
                        return null;
                    }
                })
                .catch(error => {
                    console.error(`Fehler beim Abrufen der Audiodatei (${path}): ${error}`);
                    return null;
                });
        }


        function onWsOpen(){
            state.innerText = "CONNECTED!";
            state.classList = "success";
        }
        
        function onWsClose(){
            state.innerText = "DISCONNECTED!";
            state.classList = "failure";
        }

        function onWsData(data) {
            if(data.event === 'mirror') {
                previousWait = true;
                for(let file of data.files) {
                    if(file.wait || previousWait) {
                        audioQueue = audioQueue.then(() => fetchAndPlay(file));
                    } else {
                        fetchAndPlay(file).catch(err => console.error(err));
                    }
                    previousWait = file.wait;
                }
            }
        }

        function onButtonClick() {
            audio.load();
            button.style.visibility='hidden'; 
            state.style.visibility='visible'; 
            lastCall.style.visibility='visible'; 
            setupWebSocketConnection("{{ host }}", "{{ ws_port }}", onWsOpen, onWsClose, onWsData);            
        }
 
        document.addEventListener("DOMContentLoaded", function() {
            if("{{ state }}" == "0"){
                showFullscreenOverlay("To use web-calling set -WEB (--web_caller) to 1 or 2");
            }else{
                db = new Dexie("AutodartsCaller");
                db.version(1).stores({
                sounds: `
                    path,
                    file`,
                });
            }
        });
        
    </script>
</body>
</html>