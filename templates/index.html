<!DOCTYPE html>
<html lang="en">
<head>
    <!-- https://unpkg.com/dexie/dist/dexie.js -->
    <script type="text/javascript" src="/static/js/dexie-min-3.2.4.js"></script>
    <script type="text/javascript" src="/static/js/common.js?v=1.0.1"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/static/css/common.css?v=1.0.0">
    <style>
        body{
            text-align: center;
            background-color: black;
            color: white
        }
    </style>
    <title>web-caller</title>
</head>

<body>
    <audio id="audio" preload="auto"></audio>

    <!-- <button id="button-clear"></button> -->
    
    <h4 id="app-info"> {{ app_version }} - {{ db_name }}</h4>
    <h3 id="status" style="display:none;">Disconnected!</h3>

    <button id="button-start">Start Caller!</button>

    <h2 id="caller-name" style="display:none;"></h2>
    <image src="/static/images/say.png" id="button-say" style="display:none;"></image>
    <h2 id="caller-call" style="display:none;"></h2>
    
    <button id="button-ban" style="display:none;">Ban caller!</button>
    <button id="button-change" style="display:none;">Change caller!</button>

    <button id="button-container-mod-toggle">Mods</button>
    <div id="container-mod">
        <h2>Volume</h2>
        <p>
            <div id="slider-volume-value" class="mod-value"></div>
            <input id="slider-volume" class="ranger" type="range" min="0.0" max="100.0" step="1" value="100.0">
        </p>

        <h2>Playback-Rate</h2>
        <p>
            <div id="slider-playback-rate-min-value" class="mod-value"></div>
            <input id="slider-playback-rate-min" class="ranger" type="range" min="0.01" max="2.00" step="0.01" value="1.00">
            <div id="slider-playback-rate-max-value" class="mod-value"></div>
            <input id="slider-playback-rate-max" class="ranger" type="range" min="0.01" max="2.00" step="0.01" value="1.00">         
        </p>
        <button id="button-playback-rate-reset" class="reset">Reset</button>

        <h2>Detune</h2>
        <p>
            <div id="slider-detune-min-value" class="mod-value"></div>
            <input id="slider-detune-min" class="ranger" type="range" min="-2000" max="2000" step="100" value="0">
            <div id="slider-detune-max-value" class="mod-value"></div>
            <input id="slider-detune-max" class="ranger" type="range" min="-2000" max="2000" step="100" value="0">  
        </p>
        <button id="button-detune-reset" class="reset">Reset</button>
    </div>




    <script>
        const localStorageAppKey = 'ADC';
        let db, ws, done, loading, caller_name, dexie, specific, banable, playbackRateMin, playbackRateMax, detuneMin, detuneMax, volume;
        let audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let audioQueue = Promise.resolve();
        let previousWait = false;


        playbackRateDefault = 1.0;
        detuneDefault = 0;
        volumeDefault = 100.0;

        // misc stuff
        const audio = document.getElementById('audio');
        const buttonClear = document.getElementById('app-info'); 

        // caller stuff
        const button = document.getElementById('button-start');
        const buttonChange = document.getElementById('button-change');
        const buttonBan = document.getElementById('button-ban');
        const buttonSay = document.getElementById('button-say');
        const state = document.getElementById('status');
        const callerName = document.getElementById('caller-name');
        const lastCall = document.getElementById('caller-call');

        // mod stuff
        const buttonContainerModToggle = document.getElementById('button-container-mod-toggle');
        const containerMod = document.getElementById('container-mod');

        const sliderPlaybackRateMin = document.getElementById('slider-playback-rate-min');
        const sliderPlaybackRateMinValue = document.getElementById('slider-playback-rate-min-value');
        const sliderPlaybackRateMax = document.getElementById('slider-playback-rate-max');
        const sliderPlaybackRateMaxValue = document.getElementById('slider-playback-rate-max-value');
        const buttonPlaybackRateReset = document.getElementById('button-playback-rate-reset');

        const sliderDetuneMin = document.getElementById('slider-detune-min');
        const sliderDetuneMinValue = document.getElementById('slider-detune-min-value');
        const sliderDetuneMax = document.getElementById('slider-detune-max');
        const sliderDetuneMaxValue = document.getElementById('slider-detune-max-value');
        const buttonDetuneReset = document.getElementById('button-detune-reset');

        const sliderVolume = document.getElementById('slider-volume');
        const sliderVolumeValue = document.getElementById('slider-volume-value');


        buttonContainerModToggle.addEventListener('click', onButtonContainerModToggleClick);
        buttonClear.addEventListener('click', onButtonClearClick);
        button.addEventListener('click', onButtonClick);
        buttonChange.addEventListener('click', onButtonChangeClick);
        buttonBan.addEventListener('click', onButtonBanClick);
        buttonSay.addEventListener('click', onButtonSayClick);

        sliderPlaybackRateMin.addEventListener('input', function() {
            if(this.value <= playbackRateMax){
                playbackRateMin = parseFloat(this.value);
            } else {
                playbackRateMax = parseFloat(this.value);
            }
            updatePlaybackRateSliders();
        });
        sliderPlaybackRateMax.addEventListener('input', function() {
            if(this.value >= playbackRateMin){
                playbackRateMax = parseFloat(this.value);
            } else {
                playbackRateMin = parseFloat(this.value);
            }
            updatePlaybackRateSliders();
        });
        buttonPlaybackRateReset.addEventListener('click', resetPlaybackRates);
        
        sliderDetuneMin.addEventListener('input', function() {
            if(this.value <= detuneMax){
                detuneMin = parseInt(this.value);
            } else {
                detuneMax = parseInt(this.value);
            }
            updateDetuneSliders();
        });
        sliderDetuneMax.addEventListener('input', function() {
            if(this.value >= detuneMin){
                detuneMax = parseInt(this.value);
            } else {
                detuneMin = parseInt(this.value);
            }
            updateDetuneSliders();
        });
        buttonDetuneReset.addEventListener('click', resetDetunes);

        sliderVolume.addEventListener('input', function() {
            volume = parseInt(this.value);
            updateVolumeSlider();
        });
    

        document.addEventListener("DOMContentLoaded", function() {
            console.log("APP-Version: '{{ app_version }}'");

            if("{{ state }}" == "0"){
                showFullscreenOverlay("To use web-calling set -WEB (--web_caller) to 1 or 2");
            }else{ 
                if(!checkDBCompatibility){
                    return;
                }

                console.log("USING DB: '{{ db_name }}'");
                initializeDB();

                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.has('clear')) {
                    clearDatabase();
                } 
                
                resetPlaybackRates(false);
                resetDetunes(false);
                resetVolume(false);
                loadValuesFromLocalStorage();
            }
        });

        function onButtonClearClick() {
            clearDatabase();          
        }
        
        function onButtonContainerModToggleClick(){
            if(containerMod.style.display == 'block'){
                containerMod.style.display = 'none';
            }else{
                containerMod.style.display = 'block';
            }
        }

        function onButtonClick(){
            audio.load();
            caller_name = undefined;
            state.style.display='block'; 
            lastCall.style.display='block';
            button.remove();

            setupWebSocketConnection("{{ host }}", "{{ ws_port }}", onWsOpen, onWsClose, onWsData);
        }

        function onButtonChangeClick() {
            ws.send('ban:change');            
        }

        function onButtonBanClick() {
            ws.send('ban');            
        }

        function onButtonSayClick() {
            ws.send('call:hi');            
        }

        

        function resetPlaybackRates(save = true) {
            playbackRateMin = playbackRateDefault;
            playbackRateMax = playbackRateDefault;
            updatePlaybackRateSliders(save);
        }

        function resetDetunes(save = true) {
            detuneMin = detuneDefault;
            detuneMax = detuneDefault;
            updateDetuneSliders(save);
        }

        function resetVolume(save = true){
            volume = volumeDefault;
            updateVolumeSlider(save);
        }

        function updatePlaybackRateSliders(save = true) {
            sliderPlaybackRateMin.value = playbackRateMin;
            sliderPlaybackRateMax.value = playbackRateMax;
            sliderPlaybackRateMinValue.innerHTML = playbackRateMin + " (MIN)";
            sliderPlaybackRateMaxValue.innerHTML = playbackRateMax + " (MAX)";
            if(save){
                saveValuesToLocalStorage();
            }
        }
        
        function updateDetuneSliders(save = true) {
            sliderDetuneMin.value = detuneMin;
            sliderDetuneMax.value = detuneMax;
            sliderDetuneMinValue.innerHTML = detuneMin + " (MIN)";
            sliderDetuneMaxValue.innerHTML = detuneMax + " (MAX)";
            if(save){
                saveValuesToLocalStorage();
            }
        }

        function updateVolumeSlider(save = true) {
            sliderVolume.value = volume;
            sliderVolumeValue.innerHTML = volume;
            if(save){
                saveValuesToLocalStorage();
            }
        }


        function saveValuesToLocalStorage() {
            localStorage.setItem('ADC_playbackRateMin', playbackRateMin);
            localStorage.setItem('ADC_playbackRateMax', playbackRateMax);
            localStorage.setItem('ADC_detuneMin', detuneMin);
            localStorage.setItem('ADC_detuneMax', detuneMax);
            localStorage.setItem('ADC_volume', volume);
        }

        function loadValuesFromLocalStorage() {           
            if (localStorage.getItem('ADC_playbackRateMin') !== null) {
                playbackRateMin = parseFloat(localStorage.getItem('ADC_playbackRateMin'));
            }
            if (localStorage.getItem('ADC_playbackRateMax') !== null) {
                playbackRateMax = parseFloat(localStorage.getItem('ADC_playbackRateMax'));
            }
            if (localStorage.getItem('ADC_detuneMin') !== null) {
                detuneMin = parseInt(localStorage.getItem('ADC_detuneMin'));
            }
            if (localStorage.getItem('ADC_detuneMax') !== null) {
                detuneMax = parseInt(localStorage.getItem('ADC_detuneMax'));
            }
            if (localStorage.getItem('ADC_volume') !== null) {
                volume = parseFloat(localStorage.getItem('ADC_volume'));
            }

            updatePlaybackRateSliders(false);
            updateDetuneSliders(false);
            updateVolumeSlider(false);
        }


        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function clearDatabase(){
            if(!checkDBCompatibility){
                return;
            }

            db.open().then(() => {
                        db.delete().then(() => {
                            console.log('Database cleared');
                            callerName.innerText = "Database cleared. Sync.."
                            initializeDB();
                            if(ws){
                                ws.send('hello');
                            }
                        }).catch(error => {
                            console.error('Failed to clear database', error);
                        });
                    }).catch(error => {
                        console.error('Failed to open database for clearing', error);
                    });
        }

        function checkDBCompatibility () {
            if (!('indexedDB' in window)) {
                console.log("This browser doesn't support IndexedDB");
                dexie = False;
                return false;
            }
            dexie = True;
            return true;
        }

        function initializeDB(){
            db = new Dexie("{{ db_name }}");
            db.version(1).stores({
                sounds: `
                    [caller+name],
                    path,
                    file`,
            });
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }
        
        // async function decodeAndCacheSound(caller, new_file) {
        //     const arrayBuffer = base64ToArrayBuffer(new_file.file);
        //     await db.sounds.put({ caller: caller, name: new_file.name, path: new_file.path, file: arrayBuffer });
        //     done += 1;
        //     callerName.innerText = `${caller_name} [Syncing .. ${done}]`;
        //     console.log(`Caching successful for ${new_file.name} -> ${new_file.path}`);
        // }
        
        async function downloadAndCacheSound(caller, file) {
            if(!loading){
                return;
            }

            const file_name = extractFilename(unescape(file));
            
            try {
                const result = await db.sounds.get({caller: caller, name: file_name});
                
                if (result) {
                    console.log(`Using cache for ${file_name}`);
                } else {
                    console.log(`No cache for ${file_name}`);
                    
                    await wait(Math.floor(Math.random() * 1000) + 1);

                    const fileUrl = `/sounds/${file}`;
                    const response = await fetch(fileUrl, {
                        method: "GET",
                        headers: {
                            "Content-Type": "audio/mpeg"
                        },
                    });

                    const arrayBuffer = await response.arrayBuffer();
                    const copiedAudioBuffer = arrayBuffer.slice(0);

                    await db.sounds.put({ caller: caller, name: file_name, path: file, file: copiedAudioBuffer });
                    console.log(`Caching successful for ${file_name} -> ${file}`);  
                }

                done += 1;
                lastCall.innerText = done;
            } catch (error) {
                console.error(`Error processing ${file}: ${error}`);
            }
        }

        function processAudioEvent(audioEvent) {
            return new Promise((resolve, reject) => {
                let path = audioEvent.path;

                getAudio(audioEvent)
                .then(audioBlob => {

                    // file in cache, play it!
                    if (audioBlob) {
                        playAudio(audioBlob, audioEvent, true)
                            .then(() => {
                                resolve();
                            })
                            .catch(error => {
                                console.error(error);
                                // lastCall.innerText = audioEvent.name
                                lastCall.style.color = "red";
                                reject(error);
                            });
                    } 
                    // file not cached, fetch it this time!
                    else {
                        let fileUrl = `/sounds/${path}`;
                        fetch(fileUrl, {
                            method: "GET",
                            headers: {
                                "Content-Type": "audio/mpeg"
                            },
                        })
                        .then(response => response.arrayBuffer())
                        .then(arrayBuffer => {
                            // cacheAudio(audioEvent, arrayBuffer);
                            playAudio(arrayBuffer, audioEvent, false)
                                .then(() => {
                                    resolve();
                                })
                                .catch(error => {
                                    console.error(error);
                                    reject(error);
                                });
                        })
                        .catch(err => {
                            console.error(err);
                            reject(err);
                        });
                    }
                })
                .catch(err => {
                    console.error(err);
                    reject(err);
                });
            });
        }

        function generateRandomPlaybackRate(baseValue, offsetMin, offsetMax) {
            const randomOffset = (Math.random() * 0.1) - 0.05;
            const clampedOffset = Math.max(Math.min(randomOffset, offsetMax), offsetMin);
            const finalValue = parseFloat(baseValue + clampedOffset);
            return finalValue;
        }

        function generateRandomDetune(baseValue, offsetMin, offsetMax) {
            const randomOffset = Math.floor(Math.random() * 201) - 100;
            const clampedOffset = Math.max(Math.min(randomOffset, offsetMax - baseValue), offsetMin - baseValue);
            const finalValue = baseValue + clampedOffset;
            return finalValue;
        }

        function playAudio(audioBlob, audioEvent, fromCache) {
            return new Promise((resolve, reject) => {
                audioContext.decodeAudioData(audioBlob)
                    .then(audioBuffer => {
                        let source = audioContext.createBufferSource();
                        source.buffer = audioBuffer;
                        let gainNode = audioContext.createGain();
                        let vol = volume == 0 ? audioEvent.volume : audioEvent.volume  * volume / 100;
                        console.warn('volume: ' + vol);
                        gainNode.gain.value = vol;
                        
                        if('mod' in audioEvent && audioEvent.mod){
                            // https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/playbackRate

                            // simple variant:
                            // var randomPlaybackRate = playbackRateMin + Math.random() * (playbackRateMax - playbackRateMin);
                            // randomPlaybackRate = randomPlaybackRate.toFixed(2);
                            
                            // base variant:
                            randomPlaybackRate = generateRandomPlaybackRate(audioEvent.modBasePlaybackRate, audioEvent.modOffsetPlaybackRateMin, audioEvent.modOffsetPlaybackRateMax);
                            source.playbackRate.value = randomPlaybackRate;
                            console.warn("mod playback-rate: " + randomPlaybackRate);


                            // https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/detune

                            // simple variant:
                            // var randomDetune = Math.floor(Math.random() * (detuneMax - detuneMin + 1)) + detuneMin;

                            // base-variant:
                            randomDetune = generateRandomDetune(audioEvent.modBaseDetune, audioEvent.modOffsetDetuneMin, audioEvent.modOffsetDetuneMax);
                            source.detune.value = randomDetune;
                            console.warn("mod detune: " + randomDetune);
                        }
                        
                        source.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        source.onended = () => {
                            resolve();
                        };
                        source.start();

                        lastCall.innerText = audioEvent.name;
                        if(fromCache){
                            lastCall.style = "color:orange;"
                            console.log("Play sound (by cache)", audioEvent.name);
                        }else{
                            lastCall.style = "color:lightblue;"
                            console.log("Play sound (by download)", audioEvent.name);
                        }
                    })
                    .catch(err => {
                        console.error(err);
                        reject(err);
                    });
            });
        }

        function cacheAudio(audioEvent, audioBuffer) {
            const copiedAudioBuffer = audioBuffer.slice(0);
            db.open().then(() => {
                db.sounds.put({ caller: audioEvent.caller, name: audioEvent.name, path: audioEvent.path, file: copiedAudioBuffer })
                    .then(() => {
                        console.log(`Caching successful for ${audioEvent.name} -> ${audioEvent.path})`);
                    })
                    .catch(error => {
                        console.error(`Caching failed for ${audioEvent.name} -> ${audioEvent.path}: ${error}`);
                    });
            });
        }

        function getAudio(audioEvent) {
            return db.open()
                .then(() => db.sounds.get({caller: audioEvent.caller, name: audioEvent.name}))
                .then(result => {
                    if (result) {
                        console.log(`Using cache for ${audioEvent.name}`);
                        return result.file;
                    } else {
                        console.log(`No cache for ${audioEvent.name}`);
                        return null;
                    }
                })
                .catch(error => {
                    console.error(`Cache-request failed for ${audioEvent.name}: ${error}`);
                    return null;
                });
        }

        function extractFilename(path) {
            let separator = path.includes('/') ? '/' : '\\';
            let parts = path.split(separator);
            return parts[parts.length - 1];
        }

        function setLoading(state){
            loading = state
            if(!loading){
                lastCall.style.display = 'block';
                lastCall.innerText = 'Waiting for throws ..';
                if(banable){
                    buttonBan.style.display = 'block';
                }
                if(!specific){
                    buttonChange.style.display = 'block';
                }
            }
            else{
                buttonBan.style.display = 'none';
                buttonChange.style.display = 'none';
            }
            // callerName.innerText = caller_name;
        }


        function onWsOpen(wss){
            ws = wss;

            state.innerText = "CONNECTED!";
            state.classList = "success";
            buttonContainerModToggle.style.display='block';

            // ws.send('get');
            ws.send('hello');
        }
        
        function onWsClose(ws){
            // socket = ws;

            state.innerText = "DISCONNECTED!";
            state.classList = "failure";
        }

        async function onWsData(ws, data){
            if(data.event === 'mirror'){
                previousWait = true;

                var modBasePlaybackRate = playbackRateMin + Math.random() * (playbackRateMax - playbackRateMin);
                modBasePlaybackRate = modBasePlaybackRate.toFixed(2);
                console.warn("mod base-playback-rate: " + modBasePlaybackRate);

                var modBaseDetune = Math.floor(Math.random() * (detuneMax - detuneMin + 1)) + detuneMin;
                console.warn("mod base-detune: " + modBaseDetune);

                for(let file of data.files) {
                    file['name'] = extractFilename(unescape(file.path));
                    file['modBasePlaybackRate'] = modBasePlaybackRate;
                    file['modBaseDetune'] = modBaseDetune;
                    file['modOffsetPlaybackRateMin'] = playbackRateMin;
                    file['modOffsetPlaybackRateMax'] = playbackRateMax;
                    file['modOffsetDetuneMin'] = detuneMin;
                    file['modOffsetDetuneMax'] = detuneMax;

                    if(file.wait || previousWait) {
                        audioQueue = audioQueue.then(() => processAudioEvent(file)).catch(err => console.error(err));
                    } else {
                        processAudioEvent(file).catch(err => console.error(err));
                    }
                    previousWait = file.wait;
                }
            }

            else if(data.event === 'welcome'){
                console.log('welcome by server');

                caller_name = data.caller;
                specific = data.specific;
                banable = data.banable;

                // callerName.innerText = data.caller;
                callerName.style.display = 'block';
                buttonSay.style.display = 'inline';

                const exists_db_entries = await db.sounds.where('caller').equals(data.caller).primaryKeys();
                const exists = exists_db_entries.map(entry => entry[1]);
                console.log(`${exists.length} cached files for ${data.caller}`);
                callerName.innerText = `${caller_name} [${exists.length} sounds]`;
                data['exists'] = exists;
                data['event'] = 'sync';
                setLoading(true);
                ws.send(JSON.stringify(data));


                // ws.send('sync|1.mp3');


                // // db.open()
                // //    .then(async () => {
                // // db.open()
                // //    .then(() => {
                //         // const exists_db_entries = await db.sounds.where('caller').equals(data.caller).primaryKeys();

                //         // .then(exists_db_entries => {
                //         // .primaryKeys()

                //         db.sounds.where('caller').equals(data.caller).toArray().then((exists_db_entries) => {
                //             // const exists = exists_db_entries.map(entry => entry[1]);
                //             const exists = exists_db_entries.map(entry => entry['name']);
                //             const existsStr = exists.length > 0 ? 'sync|' + exists.join('|') : 'sync|';
                //             // console.log(existsStr);

                //             // const exists_entries = await db.sounds.where('caller').equals(data.caller).toArray();
                //             // const exists = exists_entries.map(entry => entry['name']);

                //             console.log(`${exists.length} cached files for ${data.caller}`);

                //             data['exists'] = exists;
                //             data['event'] = 'sync';
                            
                //             setLoading(true);

                //             // setTimeout(function() {
                //                 // lastCall.innerHTML = existsStr;

                //                 // const encoder = new TextEncoder();
                //                 // const utf8Bytes = encoder.encode(existsStr);
                                
                //                 // ws.send(removeInvalidUTF8Characters(existsStr));
                //                 ws.send(existsStr);
                //                 // ws.send(JSON.stringify(data));
                //                 // ws.send(jsonFastStringify(data));

                //                 // ws.send(data);
      
                //             // }, 5000); 

                //         });
                // // })
                // // .catch(error => {
                // //     console.error(`Database error: ${error}`);
                // // });
            }

            else if(data.event === 'sync'){
                done = 0;
                
                if(data.exists.length == 0){
                    setLoading(false);
                    return;
                }

                const new_files = data.exists.map(new_file => {
                        const arrayBuffer = base64ToArrayBuffer(new_file.file);
                        done += 1;
                        //console.log(`decode successful for ${new_file.name} -> ${new_file.path}`);
                        return { caller: data.caller, name: new_file.name, path: new_file.path, file: arrayBuffer };
                    });
                    
                db.sounds.bulkPut(new_files).then(function(last_file) {
                    callerName.innerText = `${caller_name} [Synced ${done} sounds]`;
                    setLoading(false);
                    console.log("last sounds's id was: " + last_file);
                }).catch(Dexie.BulkError, function (e) {
                    console.error("some sounds did not succeed. However, " + 100000-e.failures.length + " sounds was added successfully");
                });
            }

            /*
            else if(data.event === 'get') {
                console.log(data.caller + " - " + data.files.length + " files");

                callerName.innerText = data.caller
                callerName.style.display = 'block'; 
                // setLoading(false);

                done = 0;
                lastCall.innerText = done;
                var limit = data.files.length

                db.open()
                    .then(async () => {
                        setLoading(true);
                        await Promise.all(data.files.slice(0, limit).map(file => downloadAndCacheSound(data.caller, file)));
                        setLoading(false);
                    })
                    .catch(error => {
                        console.error(`Database error: ${error}`);
                    });
            }
            */
            
            else{
                console.log("Unknown message");
            }
        }

    </script>
</body>
</html>
